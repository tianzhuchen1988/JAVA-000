测试系统信息：
	windows10, 8核, 16G, jdk8

使用串行GC, 指定Xmx512m和Xms512m, 没有发生fullGC, 平均生成对象9133
使用串行GC, 指定Xmx256m和Xms256m, 发生了30次fullGC, 平均生成对象4261

使用并行GC, 指定Xmx1g和Xms1g, 不指定并发GC线程数, 发生了2次fullGC, 平均生成对象13567
使用并行GC, 指定Xmx512m和Xms512m, 不指定并发GC线程数, 发生了9次fullGC, 平均生成对象8510
使用并行GC, 指定Xmx512m和Xms512m, 指定并发GC线程数为4, 发生了10次fullGC, 平均生成对象8010
使用并行GC, 指定Xmx512m和Xms512m, 指定并发GC线程数为2, 发生了9次fullGC, 平均生成对象7386
使用并行GC, 指定Xmx256m和Xms256m, 不指定并发GC线程数, 发生了50次fullGC, 平均生成对象3219

使用CMS GC, 指定Xmx512m和Xms512m, 发生了10次fullGC, 平均生成对象9557
使用CMS GC, 指定Xmx256m和Xms256m, 发生了9次fullGC, 平均生成对象4168

使用G1 GC, 指定Xmx512m和Xms512m, 期望GC停顿时间维持在50ms左右, 平均生成对象2500
使用G1 GC, 指定Xmx256m和Xms256m, 期望GC停顿时间维持在50ms左右, 平均生成对象1610
使用G1 GC, 不指定Xmx和Xms,       期望GC停顿时间维持在200ms左右, 平均生成对象2100
使用G1 GC, 指定Xmx4g和Xms4g,     期望GC停顿时间维持在200ms左右, 平均生成对象5974
使用G1 GC, 指定Xmx8g和Xms8g,     期望GC停顿时间维持在200ms左右, 平均生成对象7201

GC总结：
1、在学习GC垃圾收集相关及JVM调优时, 深刻理解串行GC, 并行GC, 并发GC, STW很重要，
串行GC：单线程的GC垃圾收集，且STW
并行GC：多线程的GC垃圾收集，且STW
并发GC：多线程的GC垃圾收集，且垃圾收集时能继续业务处理，造成少量的业务停顿
另外，觉得JVM运行时的内存结构图也是学习JVM的关键，新生代、老年代分布...
2、串行GC，在足够简单的程序里，设置合理的堆大小，能有效减少GC停顿时间，且有较优秀的吞吐量
3、并行GC，虽然在GC收集时会停顿业务，但在所有GC里，感觉吞吐量最优，在实际业务场景里，
门户网站就很适合使用并行GC，如果是高并发、秒杀场景，就得使用GC停顿较少的CMS或者G1
4、没有所谓的固定JVM参数能独步天下，设置JVM参数时需要具体业务具体分析, 
通过不断分析GC日志, 发生GC次数及FullGC次数, 通过jvisualvm等工具不断观察JVM运行时得出
适合当下的参数。
5、关于JVM调优，分配速率与肝脏新老细胞生命周期的迭代例子形象且生动，
在分配速率偏快的场景，容易导致频繁GC, 当收集速度远远慢于分配速率, 程序会很快OOM并崩溃
在分配速率偏快且更频繁的GC时, 容易导致频繁业务停顿, 业务吞吐量下降
JVM调优另一条关键思路，晋升太快。需要我们合理地设置新生代大小及配置合理的晋升JVM参数